# MPI_Lab2

Все замеры были выполнены на ARM архитектуре, процессор Apple Silicon M4.

## Task 1. Множество Мандельброта

Запуск:
- ./run.sh

В этой задаче реализовано параллельное вычисление точек множества Мандельброта с использованием OpenMP. Алгоритм основан на стохастическом подходе: точки равномерно случайно генерируются в прямоугольной области комплексной плоскости, после чего для каждой точки проверяется принадлежность множеству Мандельброта стандартной итерационной формулой. Точка считается принадлежащей множеству, если за фиксированное число итераций значение не выходит за радиус 2.

Основная вычислительная нагрузка сосредоточена в функции is_in_mandelbrot, где выполняются итерации комплексного отображения. Для каждой требуемой точки алгоритм повторяет генерацию случайных координат до тех пор, пока не будет найдена точка, принадлежащая множеству.

Параллелизация выполнена по числу генерируемых точек. Внутри параллельной области используется директива omp for с динамическим расписанием и минимальным размером чанка, что позволяет эффективно балансировать нагрузку между потоками, поскольку разные точки могут требовать разного количества попыток и итераций. Для генерации случайных чисел применяется rand_r с отдельным seed для каждого потока, что устраняет гонки данных и обеспечивает корректную работу в многопоточном режиме.

Программа принимает в качестве аргументов командной строки количество потоков и количество точек. Для измерения времени выполнения вычисления запускаются несколько раз (по умолчанию 5), после чего выводится среднее время, что снижает влияние флуктуаций, связанных с планировщиком и системой.

Экспериментальные результаты показывают хорошую масштабируемость: при увеличении числа потоков время выполнения стабильно уменьшается, ускорение близко к линейному, а эффективность остается высокой. Это подтверждает, что выбранная стратегия параллелизации и балансировки нагрузки подходит для данной задачи и эффективно использует вычислительные ресурсы.

![alt text](task1/graphs/efficiency_all.png)
![alt text](task1/graphs/speedup_all.png)
![alt text](task1/graphs/time_all.png)

## Task 2. Задача N тел

Запуск:
- ./run.sh

В данном задании реализовано численное моделирование движения системы материальных точек, взаимодействующих по закону всемирного тяготения. Для каждой точки заданы масса, начальные координаты и начальные скорости. Требуется определить траектории движения всех частиц на промежутке времени от нуля до заданного конечного момента времени t_end.

Математическая модель основана на классическом законе всемирного тяготения Ньютона. Сила, действующая на каждую частицу, вычисляется как сумма гравитационных сил со стороны всех остальных частиц системы.

Для численного интегрирования системы уравнений движения используется явный метод Эйлера. На каждом временном шаге сначала вычисляются силы, действующие на частицы, затем на их основе обновляются скорости, после чего обновляются координаты.

Алгоритм имеет вычислительную сложность O(N²) из-за необходимости учитывать взаимодействие каждой пары частиц. Для ускорения вычислений применяется параллелизация с использованием технологии OpenMP. Основной параллельный участок — вычисление гравитационных сил. При этом каждая частица обрабатывается независимо, что позволяет эффективно распараллелить вычисления между потоками.

Входные данные считываются из текстового файла: в первой строке указывается количество частиц, далее для каждой частицы задаются масса, координаты и компоненты скорости. Результаты моделирования сохраняются в файл формата CSV, где каждая строка содержит текущее время и координаты всех частиц.

Для анализа производительности предусмотрен запуск программы с различным числом потоков OpenMP. Время выполнения измеряется с помощью функции omp_get_wtime(), при этом для повышения точности итоговое время усредняется по нескольким запускам (5 по умолчанию). На основе полученных данных строятся графики времени выполнения, ускорения и параллельной эффективности, что позволяет оценить масштабируемость алгоритма.

В ходе экспериментов наблюдается характерное поведение для задач класса N-body: при отсутствии атомарных операций достигается заметное ускорение при увеличении числа потоков, однако эффективность параллелизации ограничивается пропускной способностью памяти и квадратичной сложностью алгоритма.

## Task 3. Реализация rwlock и rdlock, wrlock блокировки чтения-записи

Запуск:
- ./run.sh

В рамках работы реализованы две версии синхронизации доступа к разделяемой структуре данных: собственная реализация RWLock и стандартная реализация на базе pthread_rwlock_t.

В качестве разделяемой структуры данных используется упорядоченный односвязный список. Над списком выполняется набор типовых операций: поиск элемента (member), вставка (insert) и удаление (delete). Перед началом параллельной части работы список инициализируется фиксированным количеством элементов, которые добавляются в одном потоке. Далее несколько рабочих потоков выполняют заданное количество операций над списком в соответствии с вероятностным распределением типов операций.

Программа принимает входные параметры через стандартный ввод. Пользователь задаёт количество элементов, которые необходимо вставить в список на этапе инициализации, общее число операций, долю операций поиска и долю операций вставки. Процент операций удаления вычисляется автоматически как оставшаяся часть. Количество потоков передаётся через аргументы командной строки.

Для оценки производительности измеряется общее время выполнения параллельной части программы. Время замеряется с использованием std::chrono и выводится в миллисекундах после завершения всех потоков. Дополнительно выводится статистика по фактически выполненным операциям каждого типа, что позволяет убедиться в корректности распределения нагрузки.

Для автоматизации экспериментов используется shell-скрипт run.sh. Скрипт компилирует обе версии программы, последовательно запускает их на одинаковых входных данных и повторяет каждый тест несколько раз. Полученные времена выполнения усредняются, после чего на основе этих данных строится график с использованием gnuplot. Такой подход позволяет снизить влияние случайных флуктуаций планировщика и получить более стабильные и воспроизводимые результаты.

Эксперименты проводятся для различных сценариев нагрузки. В режиме, ориентированном на чтение (read-heavy), большинство операций составляют запросы на поиск элементов, что позволяет эффективно использовать параллелизм и shared-блокировки. В режиме, ориентированном на запись (write-heavy), основную долю составляют операции вставки, требующие эксклюзивного доступа к структуре данных и приводящие к высокой конкуренции между потоками. Сравнение этих сценариев позволяет наглядно продемонстрировать влияние характера нагрузки на эффективность различных реализаций RWLock.

Результаты экспериментов показывают, что в read-heavy сценариях обе реализации демонстрируют схожую производительность, поскольку основное время тратится на обход списка, а не на синхронизацию. В write-heavy сценариях стандартная реализация pthread_rwlock_t в среднем работает быстрее, что объясняется более зрелыми и оптимизированными алгоритмами управления блокировками, используемыми в библиотеке pthreads. Собственная реализация, несмотря на корректность, уступает по эффективности в условиях высокой конкуренции потоков.

![alt text](task3/comparison.png)
